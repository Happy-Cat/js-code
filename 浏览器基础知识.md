### 事件机制

**捕获阶段：事件发起时候，由根节点顺着目标节点形成的一条事件路径**

**目标阶段：事件到达目标节点**

**冒泡阶段：与捕获阶段相反，由目标节点顺着捕获阶段创建的路径回去**

**由于这种机制就有了事件代理的概念：**

**事件代理提出，问题产生的原因，如果有一个庞大的列表，我们要对列表中的每个节点进行绑定事件操作，这样会大量的占用内存，由于冒泡机制的存在，我们可以将事件绑定在父节点上，这样就可以在实现功能的同时节约内存的占用**

#### DOM节点

**网页整个页面就是由一系类的dom节点对象组成的节点树**

**nodeName（节点名称）**
**nodeValue（节点值）** 
**nodeType（节点类型）** 

**节点类型包括：元素节点（1）、属性节点（2）、文本节点（3）、 ... (其中，1..2..3..代表节点类型)**

- 获取元素：```getElementById``` ```getElementsByTagName``` ```getElementsByClassName``` ```getElementsByName```
- 修改元素：```innerText```  ```innerHTML```
- 添加删除元素：
    1. createElement建一个元素节点
    2. createTextNode创建一个文本节点
    3. appendChild 添加子节点
    4. insertBefore 在某个元素之前插入元素
    5. removeChild  删除子节点

### 跨域

**浏览器有同源策略，也就是说，如果协议、域名或端口有一个不同，那么ajax请求就会失败，主要为了防止CSRF攻击，CSRF攻击指跨站请求伪造**

**解决跨域的方式：**

**jsonp 就是利用 script标签没有跨域限制的漏洞。通过script标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。**

**CORS : CORS 需要浏览器和后端同时支持。服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。此时复杂请求会首先发起option预检请求，检查服务端是否允许跨域。**

**document.domain ：只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com ，只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域。**

**postMessage : 通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息.**

### 储存机制

**cookie: 一般由服务器生成，可以设置过期时间，4k存储空间，携带在请求头中，影响性能，现在已经不建议用于存储**

**localStorage: 浏览器本地存储，除非被删除，否则一直存在，5k存储空间，不参与服务器通信**

**sessionStorage: 浏览器本地存储，页面关闭清除，4k储存空间，不参与服务器通信**

**indexDB 浏览器本地存储，除非被删除，否则一直存在，储存空间不限制，不参与服务器通信**

### 缓存机制

**从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络**

**1.Service Worker : 运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS.**

**2.内存Cache ：读取内存中的数据肯定比磁盘快。可是缓存持续性很短，会随着进程的释放而释放。**

**3.磁盘Cache ： 读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。**

**4.Push Cache ： HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在。**

***Service Worker 实现缓存功能一般分为三个步骤：***

**1.首先需要先注册 Service Worker，**

**2.然后监听到 install 事件以后就可以缓存需要的文件，**

**3.那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。**

**缓存策略 强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。**

**强缓存 强缓存表示在缓存期间不需要请求，state code 为 200。可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control，且Cache-Control优先级高于 Expires。**

**协商缓存 如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。且 ETag 优先级比 Last-Modified 高。**

**对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。 这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。**

**常用 Cache-Control 值**

**public	所有内容都将被缓存(客户端和代理服务器都可缓存)**

**private	内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)**

**no-cache	必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。**

**no-store	所有内容都不会被缓存到缓存或 Internet 临时文件中**

**must-revalidation/proxy-revalidation	如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证**

**max-age=xxx (xxx is numeric)	缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高响应**


## 渲染原理

JS 有一个 JS 引擎，那么执行渲染也有一个渲染引擎。同样，渲染引擎在不同的浏览器中也不是都相同的。比如在 Firefox 中叫做 Gecko，在 Chrome 和 Safari 中都是基于 WebKit 开发的。

浏览器接收到 HTML 文件并转换为 DOM 树的过程：

```字节数据 => 字符串 => Token => Node => DOM```

网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串， 也就是我们写的代码
当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（token），这一过程在词法分析中叫做标记化（tokenization）
当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树。
以上就是浏览器从网络中接收到 HTML 文件然后一系列的转换过程。

将CSS文件转换为CSSDOM树：

```字节数据 => 字符串 => Token => Node => CSSDOM```

浏览器需要递归CSSDOM树，然后确定具体元素到底 是什么样式，这个过程很消耗资源。比如 div > a > span这样的选择器就比 直接span这样的选择器
更耗资源，因为需要递归，所以要尽可能保证层级扁平，且尽量少的添加无意义标签

**生成渲染树**
当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。
在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。
当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。

**重绘（Repaint）和回流（Reflow**）

重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。
重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘
回流是布局或者几何属性需要改变就称为回流。
回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

以下几个动作可能会导致性能问题：
- 改变 window 大小
- 改变字体
- 添加或删除样式
- 文字改变
- 定位或者浮动
- 盒模型

减少重绘和回流的建议：
1. 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）
2. 不要把节点的属性值放在一个循环里当成循环里的变量

```javascript
    for(let i = 0; i < 1000; i++) {
        // 获取 offsetTop 会导致回流，因为需要去获取正确的值
        console.log(document.querySelector('.test').style.offsetTop)
    }
```
3. 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。
4. 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame
5. CSS 选择符从右往左匹配查找，避免节点层级过多。

**为什么操作 DOM 慢**？

因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。
操作 DOM 次数一多，也就等同于一直在进行```线程之间的通信，并且操作 DOM 可能还会带来重绘回流```的情况，所以也就导致了性能上的问题。

**插入几万个 DOM，如何实现页面不卡顿**？

肯定不能一次性把几万个 DOM 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM。
大部分人应该可以想到通过 ```requestAnimationFrame 的方式去循环的插入 DOM```，其实还有种方式去解决这个问题：虚拟滚动（virtualized scroller）。
这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。

**什么情况阻塞渲染**?

首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。
然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，
这也是都建议```将 script 标签放在 body 标签底部```的原因。

当然在当下，并不是说 script 标签必须放在底部，因为你可以```给 script 标签添加 defer 或者 async 属性```。
当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。
对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。